from __future__ import annotations
import os, time, sqlite3, csv, json, subprocess, shutil
from typing import Any, Dict, List, Optional
from core.policy.guardian import PolicyEngine

DB_PATH = os.getenv("WR_CACHE_DB", "data/cache.db")
REPO_URL = "https://github.com/offensive-security/exploitdb.git"
REPO_DIR = os.getenv("WR_EXPLOITDB_DIR", "data/exploitdb")

class ExploitDBClient:
    def __init__(self, guardian: Optional[PolicyEngine] = None):
        self.guardian = guardian or PolicyEngine()
        self._ensure_db()

    def _ensure_db(self) -> None:
        os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
        with sqlite3.connect(DB_PATH) as c:
            c.execute("""
            CREATE TABLE IF NOT EXISTS exploitdb (
              id TEXT PRIMARY KEY,
              title TEXT,
              cve TEXT,
              path TEXT,
              json TEXT,
              last_seen INTEGER
            )
            """)

    def _git_ready(self) -> bool:
        return shutil.which("git") is not None

    def _sync_repo(self) -> None:
        if not self._git_ready():
            return
        os.makedirs("data", exist_ok=True)
        if not os.path.isdir(REPO_DIR):
            subprocess.run(["git", "clone", "--depth", "1", REPO_URL, REPO_DIR], check=True)
        else:
            subprocess.run(["git", "-C", REPO_DIR, "pull", "--rebase"], check=True)

    def sync(self) -> int:
        # Fallback strategy: mirror repo and parse CSV
        self._sync_repo()
        csv_path = os.path.join(REPO_DIR, "files_exploits.csv")
        if not os.path.isfile(csv_path):
            return 0
        now = int(time.time())
        count = 0
        with sqlite3.connect(DB_PATH) as c, open(csv_path, newline='', encoding='utf-8', errors='ignore') as f:
            rdr = csv.DictReader(f)
            for row in rdr:
                eid = row.get('id')
                title = row.get('description')
                cve = row.get('cve')
                file = row.get('file')
                rec = {k: row.get(k) for k in row.keys()}
                c.execute(
                    "REPLACE INTO exploitdb(id, title, cve, path, json, last_seen) VALUES(?,?,?,?,?,?)",
                    (eid, title, cve, file, json.dumps(rec), now)
                )
                count += 1
        return count

    def by_cve(self, cve: str) -> List[Dict[str,Any]]:
        with sqlite3.connect(DB_PATH) as c:
            rows = c.execute("SELECT json FROM exploitdb WHERE cve=?", (cve,)).fetchall()
            return [json.loads(r[0]) for r in rows]
