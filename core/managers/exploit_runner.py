"""Exploit Runner - Safe PoC Execution and Evidence Collection

Executes proof-of-concept exploits in sandboxed environment with safety controls.
Version: 2.0.0
"""

import subprocess
import asyncio
import logging
from pathlib import Path
<<<<<<< HEAD
from ..ui import UIManager
from core.managers.curated_exploit_manager import CuratedExploitManager
from core.config_manager import ConfigManager

class ExploitRunner:
    """Discovers and executes Proof-of-Concept (PoC) scripts from a library,
    prioritizing curated exploits."""

    def __init__(self, ui_manager: UIManager):
        self.config = ConfigManager()
        exploit_library_path = self.config.get('paths.exploit_library')
        self.library_path = Path(exploit_library_path)
        self.ui = ui_manager
        if not self.library_path.is_dir():
            raise FileNotFoundError(f"Exploit library not found at: {self.library_path}")
        self.curated_exploit_manager = CuratedExploitManager()

    def run(self, target: str, curated_exploits: list = None) -> dict:
        """
        Runs discovered exploits and prioritized curated exploits against a single target.

        Args:
            target (str): The target URL or domain.
            curated_exploits (list, optional): A list of curated exploit data (e.g., from CuratedExploitManager).
                                               These will be prioritized. Defaults to None.

        Returns:
            dict: A dictionary of confirmed vulnerabilities.
        """
        self.ui.run_subheading(f"Executing Exploit Library against {target}")
        confirmed_vulnerabilities = {}

        # 1. Run Curated Exploits first
        if curated_exploits:
            self.ui.print(f"  -> Running {len(curated_exploits)} curated exploits.")
            for curated_exploit in curated_exploits:
                exploit_name = curated_exploit.get('cve_id', 'Unknown Curated Exploit')
                self.ui.print(f"[magenta]    -> Running curated exploit: {exploit_name}...[/magenta]")
                success, evidence = self._run_curated_exploit(target, curated_exploit)
                if success:
                    self.ui.print(f"[bold green]    -> SUCCESS: {exploit_name} confirmed![/bold green]")
                    confirmed_vulnerabilities[exploit_name] = {
                        'evidence': evidence,
                        'type': 'curated_exploit',
                        'details': curated_exploit
                    }
        
        # 2. Discover and run local exploits
        local_exploits = self._discover_exploits()
        if not local_exploits and not curated_exploits:
            self.ui.print("  -> No exploits found in the library or provided as curated.")
            return {}
        
        if local_exploits:
            self.ui.print(f"  -> Discovered {len(local_exploits)} local PoC scripts.")
            for exploit_path in local_exploits:
                exploit_name = exploit_path.stem
                self.ui.print(f"[cyan]    -> Running local exploit: {exploit_name}...[/cyan]")
                success, evidence = self._run_single_exploit(target, exploit_path)
                if success:
                    self.ui.print(f"[bold green]    -> SUCCESS: {exploit_name} confirmed![/bold green]")
                    confirmed_vulnerabilities[exploit_name] = {
                        'evidence': evidence,
                        'type': 'local_poc',
                        'script': str(exploit_path)
                    }
=======
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
import tempfile
import os

logger = logging.getLogger(__name__)

class ExploitResult:
    """Represents exploit execution result."""
    def __init__(self, exploit_name: str, success: bool, evidence: str, 
                 execution_time: float, exit_code: int):
        self.exploit_name = exploit_name
        self.success = success
        self.evidence = evidence
        self.execution_time = execution_time
        self.exit_code = exit_code
        self.timestamp = datetime.utcnow()

class ExploitRunner:
    """Manages safe execution of proof-of-concept exploits."""

    def __init__(self, exploit_library_path: str = None, ui_manager=None, config: dict = None):
        self.config = config or {}
        self.library_path = Path(exploit_library_path or self.config.get('exploits', {}).get('library_path', './exploits'))
        self.ui = ui_manager

        # Safety configurations
        self.max_execution_time = self.config.get('exploits', {}).get('max_execution_time', 30)
        self.sandbox_enabled = self.config.get('exploits', {}).get('sandbox_enabled', True)
        self.max_concurrent = self.config.get('exploits', {}).get('max_concurrent', 3)

        # Validate library path
        if not self.library_path.exists():
            logger.warning(f"Exploit library not found at {self.library_path}, creating directory")
            self.library_path.mkdir(parents=True, exist_ok=True)

        logger.info(f"ExploitRunner initialized: library={self.library_path}, sandbox={self.sandbox_enabled}")

    async def run(self, target: str, exploit_filter: Optional[str] = None) -> Dict[str, Any]:
        """Run exploits against target."""
        logger.info(f"Running exploits against {target}")
        if self.ui:
            self.ui.run_subheading(f"Exploit Execution: {target}")

        results = {
            'target': target,
            'exploits_attempted': 0,
            'exploits_successful': 0,
            'confirmed_vulnerabilities': {},
            'failed_exploits': [],
            'timestamp': datetime.utcnow().isoformat()
        }

        # Discover available exploits
        exploits = self._discover_exploits(exploit_filter)
        results['exploits_attempted'] = len(exploits)

        if not exploits:
            logger.warning("No exploits found in library")
            if self.ui:
                self.ui.print("[yellow]No exploits found[/yellow]")
            return results

        logger.info(f"Discovered {len(exploits)} PoC scripts")
        if self.ui:
            self.ui.print(f"[cyan]Found {len(exploits)} exploits[/cyan]")

        # Execute exploits with concurrency control
        exploit_results = await self._execute_exploits_batch(target, exploits)

        # Process results
        for result in exploit_results:
            if result.success:
                results['exploits_successful'] += 1
                results['confirmed_vulnerabilities'][result.exploit_name] = {
                    'evidence': result.evidence,
                    'execution_time': result.execution_time,
                    'timestamp': result.timestamp.isoformat()
                }
                logger.info(f"Exploit successful: {result.exploit_name}")
                if self.ui:
                    self.ui.print(f"[green]âœ“ {result.exploit_name}[/green]")
            else:
                results['failed_exploits'].append({
                    'name': result.exploit_name,
                    'reason': result.evidence
                })
>>>>>>> a6084cc3ed82e7829e4008fdba7650ce580d27d4

        logger.info(f"Exploit execution complete: {results['exploits_successful']}/{results['exploits_attempted']} successful")

<<<<<<< HEAD
    def _discover_exploits(self) -> list[Path]:
        """Finds all Python PoC scripts in the local library."""
        return list(self.library_path.rglob('*.py'))

    def _run_single_exploit(self, target: str, script_path: Path) -> tuple[bool, str]:
        """Executes a single local PoC script in a subprocess."""
        try:
            result = subprocess.run(
                ['python3', str(script_path), target],
                capture_output=True,
                text=True,
                check=True,
                timeout=30
            )
            output = result.stdout.strip()
            if output.startswith("SUCCESS:"):
                return True, output
            return False, output
        except subprocess.TimeoutExpired:
            return False, "PoC script timed out."
        except subprocess.CalledProcessError as e:
            return False, f"PoC script failed or did not find a vulnerability. Output:\n{e.stdout}\n{e.stderr}"
        except Exception as e:
            return False, f"An unexpected error occurred while running exploit: {e}"

    def _run_curated_exploit(self, target: str, curated_exploit: dict) -> tuple[bool, str]:
        """
        (Placeholder) Executes a curated exploit.
        This would involve dynamically generating a script or using a specialized runner.
        """
        exploit_id = curated_exploit.get('exploitdb_entry', {}).get('id', 'N/A')
        exploit_title = curated_exploit.get('exploitdb_entry', {}).get('description', 'N/A')
        self.ui.print_warning(f"  -> Placeholder: Dynamically running curated exploit {exploit_id} ({exploit_title}) against {target}...")
        # In a real implementation, this would involve:
        # 1. Fetching the actual exploit code (e.g., from Exploit-DB path).
        # 2. Adapting it to the target (e.g., using ForgeManager to create a Nuclei template).
        # 3. Executing it.
        # For now, we simulate success for demonstration.
        return True, f"Simulated success for curated exploit {exploit_id} against {target}."
=======
        return results

    def _discover_exploits(self, filter_pattern: Optional[str] = None) -> List[Path]:
        """Discover PoC scripts in library."""
        if not self.library_path.exists():
            return []

        # Find all Python scripts
        all_exploits = list(self.library_path.rglob('*.py'))

        # Apply filter if provided
        if filter_pattern:
            all_exploits = [e for e in all_exploits if filter_pattern.lower() in e.stem.lower()]

        # Exclude test files and __init__.py
        exploits = [e for e in all_exploits if not e.stem.startswith('test_') and e.stem != '__init__']

        return exploits

    async def _execute_exploits_batch(self, target: str, exploits: List[Path]) -> List[ExploitResult]:
        """Execute exploits with concurrency control."""
        semaphore = asyncio.Semaphore(self.max_concurrent)

        async def run_with_semaphore(exploit_path: Path) -> ExploitResult:
            async with semaphore:
                return await self._run_single_exploit(target, exploit_path)

        tasks = [run_with_semaphore(exploit) for exploit in exploits]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Filter out exceptions
        valid_results = [r for r in results if isinstance(r, ExploitResult)]
        return valid_results

    async def _run_single_exploit(self, target: str, script_path: Path) -> ExploitResult:
        """Execute single PoC script safely."""
        exploit_name = script_path.stem
        start_time = datetime.utcnow()

        logger.debug(f"Executing exploit: {exploit_name}")

        try:
            # Build command with sandbox if enabled
            if self.sandbox_enabled:
                command = self._build_sandboxed_command(script_path, target)
            else:
                command = ['python3', str(script_path), target]

            # Execute with timeout
            proc = await asyncio.create_subprocess_exec(
                *command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env=self._get_safe_environment()
            )

            try:
                stdout, stderr = await asyncio.wait_for(
                    proc.communicate(),
                    timeout=self.max_execution_time
                )

                execution_time = (datetime.utcnow() - start_time).total_seconds()
                output = stdout.decode().strip()

                # Parse output for success indicator
                success = self._parse_exploit_output(output)
                evidence = output if success else f"No vulnerability detected
{stderr.decode()}"

                return ExploitResult(
                    exploit_name=exploit_name,
                    success=success,
                    evidence=evidence,
                    execution_time=execution_time,
                    exit_code=proc.returncode
                )

            except asyncio.TimeoutError:
                logger.warning(f"Exploit timed out: {exploit_name}")
                proc.kill()
                await proc.wait()
                return ExploitResult(
                    exploit_name=exploit_name,
                    success=False,
                    evidence="Exploit execution timed out",
                    execution_time=self.max_execution_time,
                    exit_code=-1
                )

        except Exception as e:
            logger.error(f"Exploit execution error ({exploit_name}): {e}")
            return ExploitResult(
                exploit_name=exploit_name,
                success=False,
                evidence=f"Execution error: {str(e)}",
                execution_time=0.0,
                exit_code=-1
            )

    def _build_sandboxed_command(self, script_path: Path, target: str) -> List[str]:
        """Build sandboxed execution command."""
        # Use firejail or similar sandboxing if available
        sandbox_tools = ['firejail', 'bwrap']

        for tool in sandbox_tools:
            if self._tool_available(tool):
                if tool == 'firejail':
                    return [
                        'firejail',
                        '--quiet',
                        '--net=none',
                        '--private-tmp',
                        'python3', str(script_path), target
                    ]

        # Fallback to normal execution if no sandbox available
        logger.warning("Sandbox tools not available, executing without sandbox")
        return ['python3', str(script_path), target]

    def _tool_available(self, tool: str) -> bool:
        """Check if tool is available."""
        try:
            subprocess.run([tool, '--version'], capture_output=True, timeout=1)
            return True
        except:
            return False

    def _get_safe_environment(self) -> Dict[str, str]:
        """Get safe environment variables for exploit execution."""
        # Create minimal environment
        safe_env = {
            'PATH': os.environ.get('PATH', '/usr/bin:/bin'),
            'PYTHONPATH': str(self.library_path),
            'HOME': '/tmp',
            'TMPDIR': '/tmp'
        }
        return safe_env

    def _parse_exploit_output(self, output: str) -> bool:
        """Parse exploit output to determine success."""
        success_indicators = [
            'SUCCESS:',
            'VULNERABLE',
            'EXPLOIT SUCCESSFUL',
            'CONFIRMED',
            '[+] Vulnerability confirmed'
        ]

        output_upper = output.upper()
        return any(indicator.upper() in output_upper for indicator in success_indicators)

    def add_exploit(self, exploit_code: str, name: str, metadata: Dict[str, Any] = None) -> Path:
        """Add new exploit to library."""
        exploit_file = self.library_path / f"{name}.py"

        # Add metadata header
        header = f"""#!/usr/bin/env python3
# Exploit: {name}
# Added: {datetime.utcnow().isoformat()}
# Metadata: {metadata or {}}

"""

        with open(exploit_file, 'w') as f:
            f.write(header + exploit_code)

        exploit_file.chmod(0o755)
        logger.info(f"Added exploit to library: {name}")

        return exploit_file

    def get_exploit_library_stats(self) -> Dict[str, Any]:
        """Get statistics about exploit library."""
        exploits = self._discover_exploits()

        return {
            'total_exploits': len(exploits),
            'library_path': str(self.library_path),
            'sandbox_enabled': self.sandbox_enabled,
            'max_execution_time': self.max_execution_time
        }
>>>>>>> a6084cc3ed82e7829e4008fdba7650ce580d27d4
