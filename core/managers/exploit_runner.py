"""Exploit Runner - Safe PoC Execution and Evidence Collection

Executes proof-of-concept exploits in sandboxed environment with safety controls.
Version: 2.0.0
"""

import subprocess
import asyncio
import logging
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
import tempfile
import os

logger = logging.getLogger(__name__)

class ExploitResult:
    """Represents exploit execution result."""
    def __init__(self, exploit_name: str, success: bool, evidence: str, 
                 execution_time: float, exit_code: int):
        self.exploit_name = exploit_name
        self.success = success
        self.evidence = evidence
        self.execution_time = execution_time
        self.exit_code = exit_code
        self.timestamp = datetime.utcnow()

class ExploitRunner:
    """Manages safe execution of proof-of-concept exploits."""

    def __init__(self, exploit_library_path: str = None, ui_manager=None, config: dict = None):
        self.config = config or {}
        self.library_path = Path(exploit_library_path or self.config.get('exploits', {}).get('library_path', './exploits'))
        self.ui = ui_manager

        # Safety configurations
        self.max_execution_time = self.config.get('exploits', {}).get('max_execution_time', 30)
        self.sandbox_enabled = self.config.get('exploits', {}).get('sandbox_enabled', True)
        self.max_concurrent = self.config.get('exploits', {}).get('max_concurrent', 3)

        # Validate library path
        if not self.library_path.exists():
            logger.warning(f"Exploit library not found at {self.library_path}, creating directory")
            self.library_path.mkdir(parents=True, exist_ok=True)

        logger.info(f"ExploitRunner initialized: library={self.library_path}, sandbox={self.sandbox_enabled}")

    async def run(self, target: str, exploit_filter: Optional[str] = None) -> Dict[str, Any]:
        """Run exploits against target."""
        logger.info(f"Running exploits against {target}")
        if self.ui:
            self.ui.run_subheading(f"Exploit Execution: {target}")

        results = {
            'target': target,
            'exploits_attempted': 0,
            'exploits_successful': 0,
            'confirmed_vulnerabilities': {},
            'failed_exploits': [],
            'timestamp': datetime.utcnow().isoformat()
        }

        # Discover available exploits
        exploits = self._discover_exploits(exploit_filter)
        results['exploits_attempted'] = len(exploits)

        if not exploits:
            logger.warning("No exploits found in library")
            if self.ui:
                self.ui.print("[yellow]No exploits found[/yellow]")
            return results

        logger.info(f"Discovered {len(exploits)} PoC scripts")
        if self.ui:
            self.ui.print(f"[cyan]Found {len(exploits)} exploits[/cyan]")

        # Execute exploits with concurrency control
        exploit_results = await self._execute_exploits_batch(target, exploits)

        # Process results
        for result in exploit_results:
            if result.success:
                results['exploits_successful'] += 1
                results['confirmed_vulnerabilities'][result.exploit_name] = {
                    'evidence': result.evidence,
                    'execution_time': result.execution_time,
                    'timestamp': result.timestamp.isoformat()
                }
                logger.info(f"Exploit successful: {result.exploit_name}")
                if self.ui:
                    self.ui.print(f"[green]âœ“ {result.exploit_name}[/green]")
            else:
                results['failed_exploits'].append({
                    'name': result.exploit_name,
                    'reason': result.evidence
                })

        logger.info(f"Exploit execution complete: {results['exploits_successful']}/{results['exploits_attempted']} successful")

        return results

    def _discover_exploits(self, filter_pattern: Optional[str] = None) -> List[Path]:
        """Discover PoC scripts in library."""
        if not self.library_path.exists():
            return []

        # Find all Python scripts
        all_exploits = list(self.library_path.rglob('*.py'))

        # Apply filter if provided
        if filter_pattern:
            all_exploits = [e for e in all_exploits if filter_pattern.lower() in e.stem.lower()]

        # Exclude test files and __init__.py
        exploits = [e for e in all_exploits if not e.stem.startswith('test_') and e.stem != '__init__']

        return exploits

    async def _execute_exploits_batch(self, target: str, exploits: List[Path]) -> List[ExploitResult]:
        """Execute exploits with concurrency control."""
        semaphore = asyncio.Semaphore(self.max_concurrent)

        async def run_with_semaphore(exploit_path: Path) -> ExploitResult:
            async with semaphore:
                return await self._run_single_exploit(target, exploit_path)

        tasks = [run_with_semaphore(exploit) for exploit in exploits]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Filter out exceptions
        valid_results = [r for r in results if isinstance(r, ExploitResult)]
        return valid_results

    async def _run_single_exploit(self, target: str, script_path: Path) -> ExploitResult:
        """Execute single PoC script safely."""
        exploit_name = script_path.stem
        start_time = datetime.utcnow()

        logger.debug(f"Executing exploit: {exploit_name}")

        try:
            # Build command with sandbox if enabled
            if self.sandbox_enabled:
                command = self._build_sandboxed_command(script_path, target)
            else:
                command = ['python3', str(script_path), target]

            # Execute with timeout
            proc = await asyncio.create_subprocess_exec(
                *command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env=self._get_safe_environment()
            )

            try:
                stdout, stderr = await asyncio.wait_for(
                    proc.communicate(),
                    timeout=self.max_execution_time
                )

                execution_time = (datetime.utcnow() - start_time).total_seconds()
                output = stdout.decode().strip()

                # Parse output for success indicator
                success = self._parse_exploit_output(output)
                evidence = output if success else f"No vulnerability detected
{stderr.decode()}"

                return ExploitResult(
                    exploit_name=exploit_name,
                    success=success,
                    evidence=evidence,
                    execution_time=execution_time,
                    exit_code=proc.returncode
                )

            except asyncio.TimeoutError:
                logger.warning(f"Exploit timed out: {exploit_name}")
                proc.kill()
                await proc.wait()
                return ExploitResult(
                    exploit_name=exploit_name,
                    success=False,
                    evidence="Exploit execution timed out",
                    execution_time=self.max_execution_time,
                    exit_code=-1
                )

        except Exception as e:
            logger.error(f"Exploit execution error ({exploit_name}): {e}")
            return ExploitResult(
                exploit_name=exploit_name,
                success=False,
                evidence=f"Execution error: {str(e)}",
                execution_time=0.0,
                exit_code=-1
            )

    def _build_sandboxed_command(self, script_path: Path, target: str) -> List[str]:
        """Build sandboxed execution command."""
        # Use firejail or similar sandboxing if available
        sandbox_tools = ['firejail', 'bwrap']

        for tool in sandbox_tools:
            if self._tool_available(tool):
                if tool == 'firejail':
                    return [
                        'firejail',
                        '--quiet',
                        '--net=none',
                        '--private-tmp',
                        'python3', str(script_path), target
                    ]

        # Fallback to normal execution if no sandbox available
        logger.warning("Sandbox tools not available, executing without sandbox")
        return ['python3', str(script_path), target]

    def _tool_available(self, tool: str) -> bool:
        """Check if tool is available."""
        try:
            subprocess.run([tool, '--version'], capture_output=True, timeout=1)
            return True
        except:
            return False

    def _get_safe_environment(self) -> Dict[str, str]:
        """Get safe environment variables for exploit execution."""
        # Create minimal environment
        safe_env = {
            'PATH': os.environ.get('PATH', '/usr/bin:/bin'),
            'PYTHONPATH': str(self.library_path),
            'HOME': '/tmp',
            'TMPDIR': '/tmp'
        }
        return safe_env

    def _parse_exploit_output(self, output: str) -> bool:
        """Parse exploit output to determine success."""
        success_indicators = [
            'SUCCESS:',
            'VULNERABLE',
            'EXPLOIT SUCCESSFUL',
            'CONFIRMED',
            '[+] Vulnerability confirmed'
        ]

        output_upper = output.upper()
        return any(indicator.upper() in output_upper for indicator in success_indicators)

    def add_exploit(self, exploit_code: str, name: str, metadata: Dict[str, Any] = None) -> Path:
        """Add new exploit to library."""
        exploit_file = self.library_path / f"{name}.py"

        # Add metadata header
        header = f"""#!/usr/bin/env python3
# Exploit: {name}
# Added: {datetime.utcnow().isoformat()}
# Metadata: {metadata or {}}

"""

        with open(exploit_file, 'w') as f:
            f.write(header + exploit_code)

        exploit_file.chmod(0o755)
        logger.info(f"Added exploit to library: {name}")

        return exploit_file

    def get_exploit_library_stats(self) -> Dict[str, Any]:
        """Get statistics about exploit library."""
        exploits = self._discover_exploits()

        return {
            'total_exploits': len(exploits),
            'library_path': str(self.library_path),
            'sandbox_enabled': self.sandbox_enabled,
            'max_execution_time': self.max_execution_time
        }
