<<<<<<< HEAD
from crewai import Agent
from core.managers.ai_manager import AIManager
from core.ai_agents.threat_intel_agent import ThreatIntelAgent
from typing import Dict, Any
import json

class VulnerabilityScanAgent(Agent):
    def __init__(self):
        super().__init__(
            role='Vulnerability Scanner Analyst',
            goal='Analyze and interpret the output of various security scanners to identify and prioritize true positive findings, filtering out false positives with AI assistance.',
            backstory='You are an expert at understanding the nuances of security scanner outputs. You can filter out false positives, correlate findings from different tools, and determine the real-world risk of a vulnerability by integrating threat intelligence.',
            verbose=True
        )
        self.ai_manager = AIManager()
        self.threat_intel_agent = ThreatIntelAgent()

    def analyze_scanner_output(self, scanner_output: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyzes scanner output, enriches findings with threat intelligence,
        and uses AI to filter false positives and prioritize true positives.
        """
        if isinstance(scanner_output, str):
            try:
                scanner_output = json.loads(scanner_output)
            except json.JSONDecodeError:
                scanner_output = {"raw_output": scanner_output}

        processed_findings = []
        findings_list = scanner_output.get('vulnerabilities', [scanner_output])

        for finding in findings_list:
            enriched_finding = self.threat_intel_agent.enrich_finding(finding)
            processed_findings.append(enriched_finding)

        prompt = f"""
        You are a highly skilled vulnerability analysis expert. Your task is to analyze the provided security scanner output, which has already been enriched with threat intelligence (NVD, Exploit-DB).

        Based on this comprehensive data:
        1.  **Identify and filter out likely false positives.** Look for inconsistencies, low confidence scores, or findings that lack corroborating evidence from NVD/Exploit-DB.
        2.  **Prioritize the true positive findings.** Focus on vulnerabilities with high CVSS scores, known public exploits, or clear impact.
        3.  **Correlate findings** if multiple tools reported similar issues.
        4.  **Provide a concise summary** of the most critical, actionable vulnerabilities.

        Scanner Output (Enriched):
        {json.dumps(processed_findings, indent=2)}

        Respond ONLY with a JSON object containing a 'summary' (string) and a 'prioritized_vulnerabilities' (list of dicts, each dict representing a confirmed vulnerability with its enriched details).
        """
        
        ai_analysis_raw = self.ai_manager._call_llm(prompt, system_prompt="You are a vulnerability analysis expert, skilled in false positive reduction and prioritization.", task_type='analysis')
        
        try:
            ai_analysis = json.loads(ai_analysis_raw)
            return ai_analysis
        except json.JSONDecodeError:
            return {"summary": "AI analysis failed to return valid JSON.", "prioritized_vulnerabilities": processed_findings}

=======
"""Vulnerability Scanning Agent - Automated Security Testing

Specialized agent for vulnerability detection workflows:
- Dynamic application security testing (DAST)
- Web vulnerability scanning (SQLi, XSS, SSRF, etc.)
- API security testing
- Configuration auditing
- Integration with: nuclei, nikto, wpscan, ffuf, sqlmap

Version: 2.0.0
"""

import logging
from typing import Dict, Any, List, Optional
from datetime import datetime
from secret_manager import SecretManager

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

if not logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter('[%(asctime)s] %(levelname)s [%(name)s:%(lineno)d] %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)


class VulnerabilityScanAgent:
    """Autonomous vulnerability detection and security testing agent.
    
    Coordinates DAST workflows, web vulnerability scanning, API testing,
    and automated exploitation of discovered vulnerabilities.
    
    Attributes:
        cost_tier: LLM model selection strategy
        secrets: Vault integration for credentials
        model: Selected LLM model
        llm_api_key: OpenAI API key from Vault
    """
    
    COST_TIERS = {
        'economic': 'gpt-3.5-turbo',
        'balanced': 'gpt-4',
        'high-performance': 'gpt-4o'
    }
    
    VULN_CATEGORIES = [
        'injection', 'broken_auth', 'sensitive_data', 'xxe',
        'broken_access', 'security_misconfig', 'xss', 'insecure_deserialization',
        'vulnerable_components', 'insufficient_logging', 'ssrf', 'csrf'
    ]
    
    def __init__(self, cost_tier: str = 'balanced'):
        """Initialize Vulnerability Scan Agent.
        
        Args:
            cost_tier: Model selection strategy
        
        Raises:
            ValueError: If cost_tier invalid
            RuntimeError: If Vault initialization fails
        """
        if cost_tier not in self.COST_TIERS:
            raise ValueError(f"Invalid cost_tier: {cost_tier}")
        
        self.cost_tier = cost_tier
        self.secrets = SecretManager()
        self.llm_api_key = self.secrets.get_secret('wilsons-raiders/creds', 'OPENAI_API_KEY')
        
        if not self.llm_api_key:
            raise RuntimeError("Failed to retrieve OPENAI_API_KEY")
        
        self.model = self._select_model()
        logger.info(f"VulnerabilityScanAgent initialized: model={self.model}")
    
    def _select_model(self) -> str:
        """Select LLM model based on cost tier."""
        return self.COST_TIERS[self.cost_tier]
    
    def execute_task(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Execute vulnerability scanning workflow.
        
        Args:
            data: Task specification containing:
                - targets: List of URLs/endpoints to scan
                - scope: In-scope domains/paths
                - scan_type: passive|active|aggressive
                - categories: Specific vuln categories to test
                - wordlists: Custom wordlists for fuzzing
        
        Returns:
            Dict containing:
                - vulnerabilities: List of discovered vulns with severity
                - exploitable: Auto-exploitable vulnerabilities
                - recommendations: Remediation guidance
                - status: Task completion status
        
        Raises:
            ValueError: If required parameters missing
            RuntimeError: If scanning fails
        """
        if 'targets' not in data:
            raise ValueError("Missing required parameter: targets")
        
        targets = data['targets']
        if not isinstance(targets, list):
            targets = [targets]
        
        scope = data.get('scope', [])
        scan_type = data.get('scan_type', 'active')
        categories = data.get('categories', self.VULN_CATEGORIES)
        
        logger.info(f"Executing vuln scan on {len(targets)} targets (type={scan_type})")
        
        # TODO: Implement vulnerability scanning logic
        # - Nuclei template execution
        # - Directory fuzzing (ffuf, dirsearch)
        # - SQL injection testing (sqlmap)
        # - XSS detection (dalfox)
        # - SSRF testing
        # - API security testing
        # - Automated exploitation of findings
        
        return {
            'status': 'not_implemented',
            'message': 'Full vulnerability scanning logic pending',
            'targets': targets,
            'scope': scope,
            'scan_type': scan_type,
            'categories': categories,
            'vulnerabilities': [],
            'exploitable': [],
            'recommendations': []
        }
>>>>>>> a6084cc3ed82e7829e4008fdba7650ce580d27d4
